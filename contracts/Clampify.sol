// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "./interfaces/IClampify.sol";
import "./interfaces/IClampifyToken.sol";
import "./interfaces/IBondingCurve.sol";
import "./interfaces/IClampifyGovernance.sol";
import "./ClampifyToken.sol";
import "./BondingCurve.sol";

/**
 * @title Clampify
 * @dev Main contract for the Clampify protocol, a meme token launchpad with enhanced security features
 */
contract Clampify is IClampify, AccessControl, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;
    using EnumerableSet for EnumerableSet.AddressSet;

    // Core chain id for validation
    // testnet 2
    uint256 public constant CORE_CHAIN_ID = 1114;
    // mainnet
    // uint256 public constant CORE_CHAIN_ID = 1116;


    // Roles
    bytes32 public constant GOVERNANCE_ROLE = keccak256("GOVERNANCE_ROLE");
    bytes32 public constant FEE_MANAGER_ROLE = keccak256("FEE_MANAGER_ROLE");
    bytes32 public constant DEX_INTEGRATOR_ROLE = keccak256("DEX_INTEGRATOR_ROLE");

    // State variables
    address public platformToken; // Address of the platform's governance token
    address public feeCollector;
    address public dexRouter; // DEX router address for liquidity
    address public governanceContract; // Address of governance contract

    // Fee structure (in basis points, 100 = 1%)
    uint256 public tokenCreationFee = 200; // 2% creation fee
    uint256 public tradingFee = 50; // 0.5% trading fee
    uint256 public liquidityLockFee = 10; // 0.1% liquidity lock fee
    
    // Minimum lock periods
    uint256 public minCreatorLockPeriod = 30 days; // Minimum time creator must lock tokens
    uint256 public minLiquidityLockPeriod = 180 days; // Minimum time to lock LP tokens
    
    // Token Creator Rewards
    uint256 public creatorRewardThreshold = 1000 ether; // Reward threshold in platform tokens
    uint256 public creatorRewardPercentage = 500; // 5% of fees generated by their token
    
    // Platform statistics
    uint256 public totalTokensCreated;
    uint256 public totalFeesCollected;
    uint256 public totalLiquidityLocked;
    
    // Bonding curve default parameters
    uint32 public defaultConnectorWeight = 500000; // 50% connector weight for bonding curve
    
    // Mappings
    mapping(address => TokenInfo) public tokenRegistry;
    mapping(address => SupplyLock[]) public lockedSupplies;
    mapping(address => EnumerableSet.AddressSet) private creatorTokens;
    mapping(address => uint256) public creatorRewards;
    
    // Bonding Curve instance
    IBondingCurve public bondingCurve;
    mapping(address => uint256) public tokenConnectorBalances; // Token => connector balance for bonding curve
    
    // Modifiers
    modifier onlyGovernance() {
        require(msg.sender == governanceContract, "Only governance");
        _;
    }
    
    /**
     * @dev Constructor to initialize the launchpad
     * @param _platformToken Platform governance token address
     * @param _feeCollector Address to collect fees
     * @param _dexRouter DEX router address for liquidity
     */
    constructor(
        address _platformToken,
        address _feeCollector,
        address _dexRouter
    ) {
        require(_platformToken != address(0), "Platform token cannot be zero address");
        require(_feeCollector != address(0), "Fee collector cannot be zero address");
        require(_dexRouter != address(0), "DEX router cannot be zero address");
        
        // Verify we're on Core blockchain
        require(block.chainid == CORE_CHAIN_ID, "Must be deployed on Core blockchain");
        
        platformToken = _platformToken;
        feeCollector = _feeCollector;
        dexRouter = _dexRouter;
        
        // Setup roles
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(GOVERNANCE_ROLE, msg.sender);
        _grantRole(FEE_MANAGER_ROLE, msg.sender);
        _grantRole(DEX_INTEGRATOR_ROLE, msg.sender);
        
        // Deploy bonding curve
        bondingCurve = new BondingCurve();
    }
    
    /**
     * @dev Set the governance contract address
     * @param _governanceContract Address of the governance contract
     */
    function setGovernanceContract(address _governanceContract) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(_governanceContract != address(0), "Governance cannot be zero address");
        governanceContract = _governanceContract;
        
        // Grant governance role to the contract
        _grantRole(GOVERNANCE_ROLE, _governanceContract);
    }
    
    /**
     * @dev Create a new meme token with anti-rug pull features
     * @param _name Token name
     * @param _symbol Token symbol
     * @param _totalSupply Total supply of tokens
     * @param _creatorLockPercentage Percentage of supply locked for creator (in basis points, 100 = 1%)
     * @param _creatorLockDuration Duration in seconds to lock creator tokens
     * @param _initialLiquidityAmount Amount of tokens for initial liquidity
     * @param _initialPrice Initial price in platform tokens per new token
     * @param _enableStability Enable stability mechanisms
     * @param _useBondingCurve Use bonding curve for price discovery
     * @return tokenAddress Address of the created token
     */
    function createMemeToken(
        string memory _name,
        string memory _symbol,
        uint256 _totalSupply,
        uint256 _creatorLockPercentage,
        uint256 _creatorLockDuration,
        uint256 _initialLiquidityAmount,
        uint256 _initialPrice,
        bool _enableStability,
        bool _useBondingCurve
    ) external payable override nonReentrant returns (address) {
        // Validate token parameters
        _validateTokenCreation(
            _totalSupply,
            _creatorLockPercentage,
            _creatorLockDuration,
            _initialLiquidityAmount
        );
        
        // Collect creation fee
        _collectCreationFee(_totalSupply);
        
        // Create new token
        ClampifyToken newToken = new ClampifyToken(
            _name,
            _symbol,
            _totalSupply,
            address(this)
        );
        address tokenAddress = address(newToken);
        
        // Set up token registry
        uint256 creatorLockAmount = _totalSupply.mul(_creatorLockPercentage).div(10000);
        uint256 creatorLockEndTime = block.timestamp.add(_creatorLockDuration);
        
        TokenInfo storage tokenInfo = tokenRegistry[tokenAddress];
        tokenInfo.tokenAddress = tokenAddress;
        tokenInfo.creator = msg.sender;
        tokenInfo.creationTime = block.timestamp;
        tokenInfo.totalSupply = _totalSupply;
        tokenInfo.initialPrice = _initialPrice;
        tokenInfo.creatorLockAmount = creatorLockAmount;
        tokenInfo.creatorLockEndTime = creatorLockEndTime;
        tokenInfo.isStabilityEnabled = _enableStability;
        
        // Configure stability mechanism if enabled
        if (_enableStability) {
            _configureStability(tokenInfo);
        }
        
        // Add token to creator's list
        EnumerableSet.add(creatorTokens[msg.sender], tokenAddress);
        
        // Calculate creator tokens and initial liquidity
        uint256 remainingAfterLock = _totalSupply.sub(creatorLockAmount);
        uint256 creatorAmount = remainingAfterLock.sub(_initialLiquidityAmount);
        
        // Transfer non-locked tokens to creator
        newToken.transfer(msg.sender, creatorAmount);
        
        // Lock creator's tokens
        lockSupply(tokenAddress, msg.sender, creatorLockAmount, creatorLockEndTime, false, 0, 0);
        
        // If using bonding curve, set up initial connector balance
        if (_useBondingCurve) {
            // Calculate initial connector balance based on initial price
            uint256 initialConnectorBalance = _totalSupply
                .mul(_initialPrice)
                .mul(defaultConnectorWeight)
                .div(1000000);
                
            // Store connector balance
            tokenConnectorBalances[tokenAddress] = initialConnectorBalance;
            
            // Creator needs to provide platform tokens for bonding curve reserve
            IERC20(platformToken).safeTransferFrom(msg.sender, address(this), initialConnectorBalance);
            
            // Initialize liquidity differently for bonding curve tokens
            _setupBondingCurveLiquidity(tokenAddress, _initialLiquidityAmount);
        } else {
            // Setup traditional initial liquidity with platform token
            _setupInitialLiquidity(tokenAddress, _initialLiquidityAmount, _initialPrice);
        }
        
        totalTokensCreated = totalTokensCreated.add(1);
        
        emit TokenCreated(tokenAddress, msg.sender, _totalSupply, _initialPrice);
        
        return tokenAddress;
    }
    
    /**
     * @dev Buy tokens using the bonding curve
     * @param _token Address of the token to buy
     * @param _platformAmount Amount of platform tokens to spend
     * @return _returnAmount Amount of tokens received
     */
    function buyFromBondingCurve(address _token, uint256 _platformAmount) 
        external 
        nonReentrant 
        returns (uint256 _returnAmount) 
    {
        require(_token != address(0), "Token cannot be zero address");
        require(_platformAmount > 0, "Amount must be greater than zero");
        require(tokenConnectorBalances[_token] > 0, "Token does not use bonding curve");
        
        TokenInfo storage tokenInfo = tokenRegistry[_token];
        require(tokenInfo.tokenAddress == _token, "Token not registered");
        
        // Get current supply
        uint256 currentSupply = IERC20(_token).totalSupply();
        
        // Calculate return amount
        uint256 returnAmount = bondingCurve.calculatePurchaseReturn(
            currentSupply,
            tokenConnectorBalances[_token],
            defaultConnectorWeight,
            _platformAmount
        );
        
        require(returnAmount > 0, "Return too small");
        
        // Calculate fee
        uint256 fee = returnAmount.mul(tradingFee).div(10000);
        uint256 amountAfterFee = returnAmount.sub(fee);
        
        // Update connector balance
        tokenConnectorBalances[_token] = tokenConnectorBalances[_token].add(_platformAmount);
        
        // Transfer platform tokens from buyer to contract
        IERC20(platformToken).safeTransferFrom(msg.sender, address(this), _platformAmount);
        
        // Mint tokens to buyer
        ClampifyToken(_token).mint(msg.sender, amountAfterFee);
        
        // Mint fee to fee collector
        if (fee > 0) {
            ClampifyToken(_token).mint(feeCollector, fee);
            totalFeesCollected = totalFeesCollected.add(fee);
        }
        
        return amountAfterFee;
    }
    
    /**
     * @dev Sell tokens using the bonding curve
     * @param _token Address of the token to sell
     * @param _tokenAmount Amount of tokens to sell
     * @return _returnAmount Amount of platform tokens received
     */
    function sellToBondingCurve(address _token, uint256 _tokenAmount) 
        external 
        nonReentrant 
        returns (uint256 _returnAmount) 
    {
        require(_token != address(0), "Token cannot be zero address");
        require(_tokenAmount > 0, "Amount must be greater than zero");
        require(tokenConnectorBalances[_token] > 0, "Token does not use bonding curve");
        
        TokenInfo storage tokenInfo = tokenRegistry[_token];
        require(tokenInfo.tokenAddress == _token, "Token not registered");
        
        // Ensure seller can't exceed max sell limits if clamping is active
        _validateSellAmount(msg.sender, _token, _tokenAmount);
        
        // Get current supply
        uint256 currentSupply = IERC20(_token).totalSupply();
        
        // Calculate return amount
        uint256 returnAmount = bondingCurve.calculateSaleReturn(
            currentSupply,
            tokenConnectorBalances[_token],
            defaultConnectorWeight,
            _tokenAmount
        );
        
        require(returnAmount > 0, "Return too small");
        
        // Calculate fee
        uint256 fee = returnAmount.mul(tradingFee).div(10000);
        uint256 amountAfterFee = returnAmount.sub(fee);
        
        // Update connector balance
        tokenConnectorBalances[_token] = tokenConnectorBalances[_token].sub(amountAfterFee);
        
        // Burn the tokens
        ClampifyToken(_token).burnFrom(msg.sender, _tokenAmount);
        
        // Transfer platform tokens to seller
        IERC20(platformToken).safeTransfer(msg.sender, amountAfterFee);
        
        // Transfer fee to fee collector
        if (fee > 0) {
            IERC20(platformToken).safeTransfer(feeCollector, fee);
            totalFeesCollected = totalFeesCollected.add(fee);
        }
        
        return amountAfterFee;
    }
    
    /**
     * @dev Get the current price of a token from bonding curve
     * @param _token Address of the token
     * @param _isBuy Whether checking buy or sell price
     * @param _amount Amount of tokens for sell price or platform tokens for buy price
     * @return price Current price in platform tokens per token
     */
    function getBondingCurvePrice(address _token, bool _isBuy, uint256 _amount) 
        external 
        view 
        returns (uint256 price) 
    {
        require(_token != address(0), "Token cannot be zero address");
        require(tokenConnectorBalances[_token] > 0, "Token does not use bonding curve");
        
        uint256 currentSupply = IERC20(_token).totalSupply();
        
        if (_isBuy) {
            // Calculate how many tokens would be received for _amount of platform tokens
            uint256 tokensReceived = bondingCurve.calculatePurchaseReturn(
                currentSupply,
                tokenConnectorBalances[_token],
                defaultConnectorWeight,
                _amount
            );
            
            // Price is platform tokens / tokens received
            price = _amount.mul(1e18).div(tokensReceived);
        } else {
            // Calculate how many platform tokens would be received for _amount of tokens
            uint256 platformReceived = bondingCurve.calculateSaleReturn(
                currentSupply,
                tokenConnectorBalances[_token],
                defaultConnectorWeight,
                _amount
            );
            
            // Price is platform tokens received / tokens
            price = platformReceived.mul(1e18).div(_amount);
        }
        
        return price;
    }
    
    /**
     * @dev Lock token supply for a holder to prevent dumps
     * @param _token Token address
     * @param _holder Holder address
     * @param _amount Amount to lock
     * @param _releaseTime Time when tokens will be unlocked
     * @param _isVesting Whether this is a vesting lock
     * @param _vestingStart Start time for vesting (0 if not vesting)
     * @param _vestingDuration Duration of vesting period (0 if not vesting)
     */
    function lockSupply(
        address _token,
        address _holder,
        uint256 _amount,
        uint256 _releaseTime,
        bool _isVesting,
        uint256 _vestingStart,
        uint256 _vestingDuration
    ) public override nonReentrant {
        require(_token != address(0), "Token cannot be zero address");
        require(_holder != address(0), "Holder cannot be zero address");
        require(_amount > 0, "Amount must be greater than 0");
        require(_releaseTime > block.timestamp, "Release time must be in the future");
        
        // If it's a vesting lock, verify the parameters
        if (_isVesting) {
            require(_vestingStart <= block.timestamp, "Vesting start must be now or in the past");
            require(_vestingDuration > 0, "Vesting duration must be greater than 0");
            require(_releaseTime >= _vestingStart.add(_vestingDuration), "Release time must be after vesting ends");
        }
        
        // Transfer tokens from holder to this contract
        if (msg.sender == _holder) {
            IERC20(_token).safeTransferFrom(_holder, address(this), _amount);
        } else {
            // Only the token registry can lock others' tokens
            require(tokenRegistry[_token].tokenAddress == _token, "Token not registered");
            ClampifyToken(_token).transferFrom(_holder, address(this), _amount);
        }
        
        // Create lock record
        SupplyLock memory lock = SupplyLock({
            amount: _amount,
            releaseTime: _releaseTime,
            isVesting: _isVesting,
            vestingStart: _vestingStart,
            vestingDuration: _vestingDuration,
            vestedAmount: 0
        });
        
        lockedSupplies[_token].push(lock);
        
        emit SupplyLocked(_token, _holder, _amount, _releaseTime);
    }
    
    /**
     * @dev Unlock vested tokens for a holder
     * @param _token Token address
     * @param _lockIndex Index of the lock in the holder's array
     */
    function unlockVestedTokens(address _token, uint256 _lockIndex) external override nonReentrant {
        require(_token != address(0), "Token cannot be zero address");
        require(_lockIndex < lockedSupplies[_token].length, "Invalid lock index");
        
        SupplyLock storage lock = lockedSupplies[_token][_lockIndex];
        require(lock.isVesting, "Not a vesting lock");
        require(block.timestamp >= lock.vestingStart, "Vesting not started");
        
        // Calculate vested amount
        uint256 elapsedTime = block.timestamp.sub(lock.vestingStart);
        if (elapsedTime > lock.vestingDuration) {
            elapsedTime = lock.vestingDuration;
        }
        
        uint256 totalVested = lock.amount.mul(elapsedTime).div(lock.vestingDuration);
        uint256 claimableAmount = totalVested.sub(lock.vestedAmount);
        
        require(claimableAmount > 0, "No tokens to claim");
        
        // Update vested amount
        lock.vestedAmount = lock.vestedAmount.add(claimableAmount);
        
        // Transfer vested tokens
        IERC20(_token).safeTransfer(msg.sender, claimableAmount);
        
        emit SupplyUnlocked(_token, msg.sender, claimableAmount);
    }
    
    /**
     * @dev Unlock tokens after lock period
     * @param _token Token address
     * @param _lockIndex Index of the lock in the holder's array
     */
    function unlockTokens(address _token, uint256 _lockIndex) external override nonReentrant {
        require(_token != address(0), "Token cannot be zero address");
        require(_lockIndex < lockedSupplies[_token].length, "Invalid lock index");
        
        SupplyLock storage lock = lockedSupplies[_token][_lockIndex];
        require(block.timestamp >= lock.releaseTime, "Tokens still locked");
        
        uint256 remainingAmount;
        if (lock.isVesting) {
            remainingAmount = lock.amount.sub(lock.vestedAmount);
        } else {
            remainingAmount = lock.amount;
        }
        
        require(remainingAmount > 0, "No tokens to unlock");
        
        // Remove lock by replacing with the last one and popping
        if (_lockIndex < lockedSupplies[_token].length - 1) {
            lockedSupplies[_token][_lockIndex] = lockedSupplies[_token][lockedSupplies[_token].length - 1];
        }
        lockedSupplies[_token].pop();
        
        // Transfer tokens to holder
        IERC20(_token).safeTransfer(msg.sender, remainingAmount);
        
        emit SupplyUnlocked(_token, msg.sender, remainingAmount);
    }
    
    /**
     * @dev Trigger price stabilization mechanism (burn or mint)
     * @param _token Token address
     * @param _isInflation True for inflation (mint), false for deflation (burn)
     * @param _amount Amount to mint or burn
     */
    function triggerStabilization(address _token, bool _isInflation, uint256 _amount) external override onlyRole(GOVERNANCE_ROLE) {
        require(_token != address(0), "Token cannot be zero address");
        
        TokenInfo storage tokenInfo = tokenRegistry[_token];
        require(tokenInfo.tokenAddress == _token, "Token not registered");
        require(tokenInfo.isStabilityEnabled, "Stability not enabled for token");
        
        StabilityConfig storage stability = tokenInfo.stabilityConfig;
        require(block.timestamp >= stability.lastStabilizationTime.add(stability.cooldownPeriod), "Cooldown period not elapsed");
        
        // Check amount is within allowed limits
        uint256 maxAmount = tokenInfo.totalSupply.mul(stability.maxStabilizationAmount).div(10000);
        require(_amount <= maxAmount, "Stabilization amount too large");
        
        // Execute stabilization
        if (_isInflation) {
            // Mint new tokens to contract
            ClampifyToken(_token).mint(address(this), _amount);
            
            // If token uses bonding curve, adjust curve parameters
            if (tokenConnectorBalances[_token] > 0) {
                _adjustBondingCurveForInflation(_token, _amount);
            }
        } else {
            // Burn tokens from circulation
            // For simplicity, we'll burn from this contract's balance
            // In a real implementation, you'd have a reserve for this
            uint256 contractBalance = IERC20(_token).balanceOf(address(this));
            require(contractBalance >= _amount, "Insufficient balance for burn");
            
            ClampifyToken(_token).burn(_amount);
            
            // If token uses bonding curve, adjust curve parameters
            if (tokenConnectorBalances[_token] > 0) {
                _adjustBondingCurveForDeflation(_token, _amount);
            }
        }
        
        // Update stabilization timestamp
        stability.lastStabilizationTime = block.timestamp;
        
        // Update total supply
        if (_isInflation) {
            tokenInfo.totalSupply = tokenInfo.totalSupply.add(_amount);
        } else {
            tokenInfo.totalSupply = tokenInfo.totalSupply.sub(_amount);
        }
        
        emit StabilityTriggered(_token, _isInflation, _amount, 0); // Price change would be calculated in real implementation
    }
    
    /**
     * @dev Setup initial liquidity for a token
     * @param _token Token address
     * @param _tokenAmount Amount of tokens for liquidity
     * @param _initialPrice Initial price in platform tokens per new token
     */
    function _setupInitialLiquidity(address _token, uint256 _tokenAmount, uint256 _initialPrice) internal {
        // Calculate required platform tokens for liquidity
        uint256 platformAmount = _tokenAmount.mul(_initialPrice).div(1e18);
        
        // Transfer platform tokens from creator
        IERC20(platformToken).safeTransferFrom(msg.sender, address(this), platformAmount);
        
        // In a real implementation, we would:
        // 1. Approve DEX router to spend tokens
        // 2. Call router.addLiquidity to create the LP tokens
        // 3. Lock the LP tokens for the required period
        
        // For this implementation, we'll simulate the LP token creation and locking
        address lpToken = _token; // Placeholder, would be the actual LP token from DEX
        uint256 lockEndTime = block.timestamp.add(minLiquidityLockPeriod);
        
        // Update token info with liquidity lock data
        TokenInfo storage tokenInfo = tokenRegistry[_token];
        tokenInfo.hasLiquidityLocked = true;
        tokenInfo.liquidityLockEndTime = lockEndTime;
        
        totalLiquidityLocked = totalLiquidityLocked.add(_tokenAmount);
        
        emit LiquidityLocked(_token, lpToken, _tokenAmount, lockEndTime);
    }
    
    /**
     * @dev Setup initial bonding curve liquidity
     * @param _token Token address
     * @param _tokenAmount Amount of tokens to allocate
     */
    function _setupBondingCurveLiquidity(address _token, uint256 _tokenAmount) internal {
        // For bonding curve tokens, we don't need to add liquidity to a DEX
        // Instead, we just reserve the tokens in the contract to be used
        // by the bonding curve mechanism
        
        // Mark token as having locked liquidity
        TokenInfo storage tokenInfo = tokenRegistry[_token];
        tokenInfo.hasLiquidityLocked = true;
        tokenInfo.liquidityLockEndTime = block.timestamp.add(minLiquidityLockPeriod);
        
        // The tokens are already in the contract from initial creation
        // No transfer needed
        
        totalLiquidityLocked = totalLiquidityLocked.add(_tokenAmount);
        
        emit LiquidityLocked(_token, _token, _tokenAmount, tokenInfo.liquidityLockEndTime);
    }
    
    /**
     * @dev Adjust bonding curve after inflation (minting)
     * @param _token Token address
     * @param _mintAmount Amount of tokens minted
     */
    function _adjustBondingCurveForInflation(address _token, uint256 _mintAmount) internal {
        // When minting tokens, we need to adjust the connector balance 
        // to maintain price stability
        
        // Calculate current price
        uint256 currentSupply = IERC20(_token).totalSupply().sub(_mintAmount); // Supply before mint
        uint256 newSupply = currentSupply.add(_mintAmount);
        
        // Calculate additional connector tokens needed
        // Simplified for this implementation
        uint256 additionalConnector = tokenConnectorBalances[_token]
            .mul(_mintAmount)
            .mul(defaultConnectorWeight)
            .div(currentSupply)
            .div(1000000);
            
        // Update connector balance
        tokenConnectorBalances[_token] = tokenConnectorBalances[_token].add(additionalConnector);
    }
    
    /**
     * @dev Adjust bonding curve after deflation (burning)
     * @param _token Token address
     * @param _burnAmount Amount of tokens burned
     */
    function _adjustBondingCurveForDeflation(address _token, uint256 _burnAmount) internal {
        // When burning tokens, we need to adjust the connector balance 
        // to maintain price stability
        
        // Calculate current price
        uint256 currentSupply = IERC20(_token).totalSupply().add(_burnAmount); // Supply before burn
        uint256 newSupply = currentSupply.sub(_burnAmount);
        
        // Calculate connector tokens to remove
        // Simplified for this implementation
        uint256 connectorToRemove = tokenConnectorBalances[_token]
            .mul(_burnAmount)
            .mul(defaultConnectorWeight)
            .div(currentSupply)
            .div(1000000);
            
        // Update connector balance
        if (connectorToRemove < tokenConnectorBalances[_token]) {
            tokenConnectorBalances[_token] = tokenConnectorBalances[_token].sub(connectorToRemove);
        }
    }
    
    /**
     * @dev Configure stability mechanism for a token
     * @param tokenInfo Token info to configure
     */
    function _configureStability(TokenInfo storage tokenInfo) internal {
        StabilityConfig storage stability = tokenInfo.stabilityConfig;
        stability.enableAutoStabilize = true;
        stability.upperPriceThreshold = 2000; // 20% price increase
        stability.lowerPriceThreshold = 1500; // 15% price decrease
        stability.maxStabilizationAmount = 500; // 5% of supply
        stability.cooldownPeriod = 1 days; // 1 day cooldown
        stability.lastStabilizationTime = block.timestamp;
    }
    
 /**
     * @dev Validate token creation parameters
     * @param _totalSupply Total supply
     * @param _creatorLockPercentage Creator lock percentage
     * @param _creatorLockDuration Creator lock duration
     * @param _initialLiquidityAmount Initial liquidity amount
     */
    function _validateTokenCreation(
        uint256 _totalSupply,
        uint256 _creatorLockPercentage,
        uint256 _creatorLockDuration,
        uint256 _initialLiquidityAmount
    ) internal view {
        require(_totalSupply > 0, "Total supply must be greater than 0");
        require(_creatorLockPercentage > 0, "Creator lock percentage must be greater than 0");
        require(_creatorLockPercentage <= 10000, "Creator lock percentage must be <= 100%");
        require(_creatorLockDuration >= minCreatorLockPeriod, "Lock duration too short");
        require(_initialLiquidityAmount > 0, "Initial liquidity must be greater than 0");
        require(_initialLiquidityAmount < _totalSupply, "Liquidity exceeds total supply");
    }
    
    /**
     * @dev Collect creation fee
     * @param _totalSupply Total supply
     */
    function _collectCreationFee(uint256 _totalSupply) internal {
        uint256 creationFee = _totalSupply.mul(tokenCreationFee).div(10000);
        IERC20(platformToken).safeTransferFrom(msg.sender, feeCollector, creationFee);
        totalFeesCollected = totalFeesCollected.add(creationFee);
    }
    
    /**
     * @dev Validate if a sell amount is allowed under clamping restrictions
     * @param _seller Seller address
     * @param _token Token address
     * @param _amount Amount to sell
     */
    function _validateSellAmount(address _seller, address _token, uint256 _amount) internal view {
        // This is where you would implement your clamping logic for sell limits
        // For example:
        // 1. Check if seller is trying to sell too much in a 24-hour period
        // 2. Enforce graduated release schedules
        // 3. Apply market stress detection
        
        // For this implementation, we'll use a simple check:
        TokenInfo storage tokenInfo = tokenRegistry[_token];
        uint256 holderBalance = IERC20(_token).balanceOf(_seller);
        
        // Default max sell: 3% of holdings per day
        uint256 maxSellPercentage = 300; // 3% in basis points
        uint256 maxSellAmount = holderBalance.mul(maxSellPercentage).div(10000);
        
        require(_amount <= maxSellAmount, "Sell amount exceeds daily limit");
    }
    
    /**
     * @dev Get creator's tokens
     * @param _creator Creator address
     * @return Array of token addresses created by this creator
     */
    function getCreatorTokens(address _creator) external view returns (address[] memory) {
        uint256 tokenCount = EnumerableSet.length(creatorTokens[_creator]);
        address[] memory tokens = new address[](tokenCount);
        
        for (uint256 i = 0; i < tokenCount; i++) {
            tokens[i] = EnumerableSet.at(creatorTokens[_creator], i);
        }
        
        return tokens;
    }
    
    /**
     * @dev Get token information
     * @param _token Token address
     * @return tokenAddress The address of the token
     * @return creator The creator of the token
     * @return creationTime When the token was created
     * @return totalSupply Total supply of the token
     * @return initialPrice Initial price of the token
     * @return creatorLockAmount Amount of tokens locked for creator
     * @return creatorLockEndTime When creator tokens unlock
     * @return liquidityLockEndTime When liquidity unlocks
     * @return hasLiquidityLocked Whether liquidity is locked
     * @return isStabilityEnabled Whether stability features are enabled
     * @return isVerified Whether the token is verified
     */
    function getTokenInfo(address _token) external view returns (
        address tokenAddress,
        address creator,
        uint256 creationTime,
        uint256 totalSupply,
        uint256 initialPrice,
        uint256 creatorLockAmount,
        uint256 creatorLockEndTime,
        uint256 liquidityLockEndTime,
        bool hasLiquidityLocked,
        bool isStabilityEnabled,
        bool isVerified
    ) {
        TokenInfo storage info = tokenRegistry[_token];
        return (
            info.tokenAddress,
            info.creator,
            info.creationTime,
            info.totalSupply,
            info.initialPrice,
            info.creatorLockAmount,
            info.creatorLockEndTime,
            info.liquidityLockEndTime,
            info.hasLiquidityLocked,
            info.isStabilityEnabled,
            info.isVerified
        );
    }
    
    /**
     * @dev Get token stability configuration
     * @param _token Token address
     * @return enableAutoStabilize Whether auto-stabilization is enabled
     * @return upperPriceThreshold Upper price threshold for stability
     * @return lowerPriceThreshold Lower price threshold for stability
     * @return maxStabilizationAmount Maximum amount for stabilization
     * @return cooldownPeriod Cooldown period between stabilizations
     * @return lastStabilizationTime Last time stability was triggered
     */
    function getStabilityConfig(address _token) external view returns (
        bool enableAutoStabilize,
        uint256 upperPriceThreshold,
        uint256 lowerPriceThreshold,
        uint256 maxStabilizationAmount,
        uint256 cooldownPeriod,
        uint256 lastStabilizationTime
    ) {
        TokenInfo storage info = tokenRegistry[_token];
        StabilityConfig storage stability = info.stabilityConfig;
        return (
            stability.enableAutoStabilize,
            stability.upperPriceThreshold,
            stability.lowerPriceThreshold,
            stability.maxStabilizationAmount,
            stability.cooldownPeriod,
            stability.lastStabilizationTime
        );
    }
    
    /**
     * @dev Get locked supplies for a token
     * @param _token Token address
     * @return Array of supply locks
     */
    function getLockedSupplies(address _token) external view returns (SupplyLock[] memory) {
        return lockedSupplies[_token];
    }
    
    /**
     * @dev Set the connector weight for bonding curves
     * @param _newWeight New connector weight (1-1000000)
     */
    function setDefaultConnectorWeight(uint32 _newWeight) external onlyRole(GOVERNANCE_ROLE) {
        require(_newWeight > 0 && _newWeight <= 1000000, "Invalid weight");
        defaultConnectorWeight = _newWeight;
    }
    
    /**
     * @dev Set the platform fee percentage
     * @param _newFee New fee percentage (basis points, 100 = 1%)
     */
    function setPlatformFee(uint256 _newFee) external onlyRole(FEE_MANAGER_ROLE) {
        require(_newFee <= 1000, "Fee cannot exceed 10%");
        tokenCreationFee = _newFee;
    }
    
    /**
     * @dev Set the trading fee percentage
     * @param _newFee New fee percentage (basis points, 100 = 1%)
     */
    function setTradingFee(uint256 _newFee) external onlyRole(FEE_MANAGER_ROLE) {
        require(_newFee <= 500, "Fee cannot exceed 5%");
        tradingFee = _newFee;
    }
    
    /**
     * @dev Set the liquidity lock fee percentage
     * @param _newFee New fee percentage (basis points, 100 = 1%)
     */
    function setLiquidityLockFee(uint256 _newFee) external onlyRole(FEE_MANAGER_ROLE) {
        require(_newFee <= 200, "Fee cannot exceed 2%");
        liquidityLockFee = _newFee;
    }
    
    /**
     * @dev Set the fee collector address
     * @param _newCollector New fee collector address
     */
    function setFeeCollector(address _newCollector) external onlyRole(FEE_MANAGER_ROLE) {
        require(_newCollector != address(0), "Cannot be zero address");
        feeCollector = _newCollector;
    }
    
    /**
     * @dev Update DEX router address
     * @param _newRouter New DEX router address
     */
    function updateDexRouter(address _newRouter) external onlyRole(DEX_INTEGRATOR_ROLE) {
        require(_newRouter != address(0), "New router cannot be zero address");
        dexRouter = _newRouter;
    }
    
    /**
     * @dev Set the connector balance for a token's bonding curve
     * @param _token Token address
     * @param _newBalance New connector balance
     */
    function setConnectorBalance(address _token, uint256 _newBalance) external onlyRole(GOVERNANCE_ROLE) {
        require(_token != address(0), "Token cannot be zero address");
        require(tokenRegistry[_token].tokenAddress == _token, "Token not registered");
        
        tokenConnectorBalances[_token] = _newBalance;
    }
    
    /**
     * @dev Get the current connector balance for a token's bonding curve
     * @param _token Token address
     * @return Current connector balance
     */
    function getConnectorBalance(address _token) external view returns (uint256) {
        return tokenConnectorBalances[_token];
    }
    
    /**
     * @dev Update the minimum lock periods
     * @param _minCreatorLock Minimum creator lock period in seconds
     * @param _minLiquidityLock Minimum liquidity lock period in seconds
     */
    function setMinLockPeriods(uint256 _minCreatorLock, uint256 _minLiquidityLock) external onlyRole(GOVERNANCE_ROLE) {
        require(_minCreatorLock >= 7 days, "Creator lock too short");
        require(_minLiquidityLock >= 30 days, "Liquidity lock too short");
        
        minCreatorLockPeriod = _minCreatorLock;
        minLiquidityLockPeriod = _minLiquidityLock;
    }
    
    /**
     * @dev Set creator reward parameters
     * @param _threshold Threshold amount for rewards
     * @param _percentage Percentage of fees to distribute (basis points)
     */
    function setCreatorRewards(uint256 _threshold, uint256 _percentage) external onlyRole(GOVERNANCE_ROLE) {
        require(_percentage <= 2000, "Percentage cannot exceed 20%");
        
        creatorRewardThreshold = _threshold;
        creatorRewardPercentage = _percentage;
    }
    
    /**
     * @dev Claim creator rewards
     */
    function claimCreatorRewards() external nonReentrant {
        uint256 rewardAmount = creatorRewards[msg.sender];
        require(rewardAmount > 0, "No rewards to claim");
        
        creatorRewards[msg.sender] = 0;
        IERC20(platformToken).safeTransfer(msg.sender, rewardAmount);
        
        emit CreatorRewarded(msg.sender, address(0), rewardAmount);
    }
    
    /**
     * @dev Add rewards for a creator
     * @param _creator Creator address
     * @param _amount Amount to add to rewards
     */
    function addCreatorReward(address _creator, uint256 _amount) external onlyRole(FEE_MANAGER_ROLE) {
        require(_creator != address(0), "Creator cannot be zero address");
        
        creatorRewards[_creator] = creatorRewards[_creator].add(_amount);
        
        emit CreatorRewarded(_creator, address(0), _amount);
    }
    
    /**
     * @dev Verify a token (adds trust indicator)
     * @param _token Token address
     * @param _isVerified Whether the token is verified
     */
    function verifyToken(address _token, bool _isVerified) external onlyRole(GOVERNANCE_ROLE) {
        require(_token != address(0), "Token cannot be zero address");
        require(tokenRegistry[_token].tokenAddress == _token, "Token not registered");
        
        tokenRegistry[_token].isVerified = _isVerified;
    }
    
    /**
     * @dev Update stability parameters for a token through governance
     * @param _token Token address
     * @param _enableAutoStabilize Whether to enable auto-stabilization
     * @param _upperThreshold Upper price threshold (basis points)
     * @param _lowerThreshold Lower price threshold (basis points)
     * @param _maxAmount Maximum stabilization amount (basis points of supply)
     * @param _cooldown Cooldown period between stabilizations (seconds)
     */
    function updateTokenStabilityParams(
        address _token,
        bool _enableAutoStabilize,
        uint256 _upperThreshold,
        uint256 _lowerThreshold,
        uint256 _maxAmount,
        uint256 _cooldown
    ) external onlyGovernance {
        require(_token != address(0), "Token cannot be zero address");
        
        TokenInfo storage tokenInfo = tokenRegistry[_token];
        require(tokenInfo.tokenAddress == _token, "Token not registered");
        
        // Update stability settings
        tokenInfo.isStabilityEnabled = true;
        StabilityConfig storage stability = tokenInfo.stabilityConfig;
        stability.enableAutoStabilize = _enableAutoStabilize;
        stability.upperPriceThreshold = _upperThreshold;
        stability.lowerPriceThreshold = _lowerThreshold;
        stability.maxStabilizationAmount = _maxAmount;
        stability.cooldownPeriod = _cooldown;
    }
    
    /**
     * @dev Extend liquidity lock period through governance
     * @param _token Token address
     * @param _newLockEndTime New time when liquidity lock ends
     */
    function extendLiquidityLock(address _token, uint256 _newLockEndTime) external onlyGovernance {
        require(_token != address(0), "Token cannot be zero address");
        
        TokenInfo storage tokenInfo = tokenRegistry[_token];
        require(tokenInfo.tokenAddress == _token, "Token not registered");
        require(tokenInfo.hasLiquidityLocked, "No liquidity locked");
        require(_newLockEndTime > tokenInfo.liquidityLockEndTime, "New end time must be later");
        
        tokenInfo.liquidityLockEndTime = _newLockEndTime;
    }
    
    /**
     * @dev Recover tokens accidentally sent to the contract (admin only)
     * @param _token Token address
     * @param _amount Amount to recover
     * @param _recipient Recipient address
     */
    function recoverTokens(address _token, uint256 _amount, address _recipient) external onlyRole(DEFAULT_ADMIN_ROLE) {
        // Cannot recover locked tokens or platform tokens used for bonding curves
        if (tokenRegistry[_token].tokenAddress == _token) {
            require(false, "Cannot recover registered tokens");
        } else {
            IERC20(_token).safeTransfer(_recipient, _amount);
        }
    }
    
    /**
     * @dev Execute contract call through governance
     * @param _target Target contract address
     * @param _callData Call data for function execution
     * @return success Whether the call succeeded
     */
    function executeGovernanceCall(address _target, bytes calldata _callData) external onlyGovernance returns (bool success) {
        require(_target != address(0), "Target cannot be zero address");
        
        // Execute the call
        (success, ) = _target.call(_callData);
        require(success, "Call execution failed");
        
        return success;
    }
    
    /**
     * @dev Create a token with custom parameters through governance
     * This allows governance to create special tokens with different parameters
     */
    function governanceCreateToken(
        string memory _name,
        string memory _symbol,
        uint256 _totalSupply,
        address _recipient,
        uint256 _creatorLockPercentage,
        uint256 _creatorLockDuration
    ) external onlyGovernance returns (address) {
        // Create new token
        ClampifyToken newToken = new ClampifyToken(
            _name,
            _symbol,
            _totalSupply,
            address(this)
        );
        address tokenAddress = address(newToken);
        
        // Set up token info
        uint256 creatorLockAmount = _totalSupply.mul(_creatorLockPercentage).div(10000);
        uint256 creatorLockEndTime = block.timestamp.add(_creatorLockDuration);
        
        TokenInfo storage tokenInfo = tokenRegistry[tokenAddress];
        tokenInfo.tokenAddress = tokenAddress;
        tokenInfo.creator = _recipient; // Governance created but recipient is considered creator
        tokenInfo.creationTime = block.timestamp;
        tokenInfo.totalSupply = _totalSupply;
        tokenInfo.initialPrice = 0; // Custom token may not have initial price
        tokenInfo.creatorLockAmount = creatorLockAmount;
        tokenInfo.creatorLockEndTime = creatorLockEndTime;
        tokenInfo.isVerified = true; // Governance-created tokens are auto-verified
        
        // Add token to recipient's list
        EnumerableSet.add(creatorTokens[_recipient], tokenAddress);
        
        // Calculate amounts
        uint256 remainingAmount = _totalSupply.sub(creatorLockAmount);
        
        // Transfer non-locked tokens to recipient
        newToken.transfer(_recipient, remainingAmount);
        
        // Lock creator tokens if specified
        if (creatorLockAmount > 0) {
            lockSupply(tokenAddress, _recipient, creatorLockAmount, creatorLockEndTime, false, 0, 0);
        }
        
        totalTokensCreated = totalTokensCreated.add(1);
        
        emit TokenCreated(tokenAddress, _recipient, _totalSupply, 0);
        
        return tokenAddress;
    }
}